# DynaCLR.JS

Open source project allowing developers to quickly and easily write and execute C#.NET and VB.NET code in-process and asynchronously, while keeping the syntax simple like Synchronous programming. This project is similar to Edge.JS, however it has the added benefit that it is very easy to distribute! Everything is self contained within a single node module and executable without any wasted space.

# Examples

## Example 01a - Simple VB.NET Example

```
/**
 *  The Common Language Runtime (CLR) is an Execution Environment.
 * It works as an interface between Operating Systems and applications written in
 * .Net languages. CLR can therefore convert Managed code into Native code and then
 * execute the Program.
 *
 * In this example we demonstrate the compilation and execution of a basic VB.NET application.
 */
 
const CLR = require('dynaclr').new()
code = `
Imports System.Windows.Forms
Class Foo
	Public Sub Test()
		MessageBox.Show("Hello, world, from VB!")
	End Sub
End Class
`

References = ["System.dll","System.Windows.Forms.dll"]
asm 	=	CLR.CompileAssembly(code, References, "System", "Microsoft.VisualBasic.VBCodeProvider")
obj 	=	CLR.CreateObject(asm, "Foo")
status	=	CLR.Execute(obj,"Test")
CLR.Finally(function(){
	if (status.value=='true'){
		console.log("The application ran successfully")
	} else {
		console.log("The application didn't run successfully")
	}
});
```

## Example 01a - Simple C#.NET Example

```
/**
 *  The Common Language Runtime (CLR) is an Execution Environment.
 * It works as an interface between Operating Systems and applications written in
 * .Net languages. CLR can therefore convert Managed code into Native code and then
 * execute the Program.
 *
 * In this example we demonstrate the compilation and execution of a basic VB.NET application.
 */
 
const CLR = require('DynaCLR').new()
code = `
using System.Windows.Forms;
class Foo {
	public void Test() {
		MessageBox.Show("Hello, world, from C#!");
	}
}
`

References = ["System.dll","System.Windows.Forms.dll"]
asm 	=	CLR.CompileAssembly(code, References, "System", "Microsoft.CSharp.CSharpCodeProvider")
obj 	=	CLR.CreateObject(asm, "Foo")
status	=	CLR.Execute(obj,"Test")
CLR.Finally(function(){
	if (status.value=='true'){
		console.log("The application ran successfully")
	} else {
		console.log("The application didn't run successfully")
	}
});
```

## Notes on functionality

Given the nature of this library, you are given the full flexibility of CLR including the ability to compile code directly to binaries if you desire.

For this reason, code may appear more complex  than Edge.JS, but it is also more flexible than Edge.JS.

Regardless, if one wants to recreate edge's function definition protocol, it is possible to recreate this with DynaCLR if desired.

# API Reference:

## CLR.AppDomain.New( AppDomain [, BaseDirectory ] )

Starts a new AppDomain and stores a pointer or reference to it in AppDomain. This can be passed to CLR_LoadLibrary() to load an assembly into the AppDomain. BaseDirectory defines the base search path used when loading assemblies into the AppDomain. BaseDirectory must be a StringPointer created with CLR.StringInject()

## CLR.AppDomain.Drop( AppDomain )

Stops the specified AppDomain and attempts to unload any assemblies that were loaded into it.

## CLR.LoadLibrary( AssemblyName [, AppDomain ] )

Loads an assembly, where AssemblyName is its full name, partial name or path*. Optionally loads the assembly into the given AppDomain instead of the default AppDomain. Returns a pointer or reference to the Assembly, which can be used with CLR_CreateObject.
Note: Once an assembly is loaded, it can only be unloaded by stopping the AppDomain which contains it.

* = Path may not work correctly, will add this to the to do list.

## CLR.CreateObject( Assembly, sType [, Arg1, Arg2 ... ] )

Instantiates an object of the specified type from the specified assembly. Optionally accepts a list of arguments* to pass to the object's constructor.

* = Arguments may not work appropriately when typed. Requires further testing.

## CLR.CompileAssembly(CodePtr, References, ProviderAssembly, ProviderType [, AppDomain, FileName*, CompilerOptions])

* = FileName is passed as a pointer to an injected string.

Compile the specified C# or VB code. If FileName is omitted, the assembly is compiled "in-memory" and automatically loaded. DLL and EXE files may be generated. Specify for References a pipe (|) delimited list of assemblies that the code requires. If FileName is omitted and compilation is successful, returns a pointer or reference to the compiled Assembly, which can be used with CLR_CreateObject; otherwise returns FileName on success or 0 on failure.
Note: Some versions of .NET may require an explicit reference to the appropriate language dll, such as Microsoft.CSharp.dll.
Additional command-line arguments can be passed to the compiler via CompilerOptions. For instance, if FileName specifies an .exe file, a console app is generated unless CompilerOptions includes "/target:winexe".

## CLR.Finally()
Often it is desired to run a Javascript script after the previous function has been executed. Since DynaCLR is asynchronous, finally is required to execute commands after other commands registered beforehand.

## CLR.StringInject(string,newLinePlaceholder) [not-often needed]
Returns a pointer to a string in memory. This function stands as a utility function and is used in numerous of the functions defined above. You will only ever need to use this if you use '__CLR-CrLf__' in your strings. If you do, then pass a new line placeholder as the 2nd argument to this function, and then send the function to CompileAssembly or otherwise.

## CLR.StringReturn(stringPtr) [not-often needed]
Returns a string from a string pointer. Useful for testing StringInject.
